<html>
<head>
</head>
<body>
	<button id="buttonRestart">Restart</button>
	<button id="buttonPause">Pause</button>
	<button id="buttonContinue" style="display: none;">Continue</button>
	<div>
		<input id="timeSlider" type=range value=0 step=1 min=0 max=0/>
	</div>
	<div id="signalGraphParent">
		<div id="signalGraphView"></div>
	</div>

<style>
#signalGraphParent {
	overflow: scroll;
	width: 100%;
}

#signalGraphView {
	-webkit-transform: scale(0.7);
	-webkit-transform-origin: 0% 0%;
	-moz-transform: scale(0.5);
	-moz-transform-origin: 0% 0%;
}

#timeSlider {
	width: 100%;
}
</style>
<script src="/debugger/viz.js"></script>
<script>
if (!String.prototype.format) {
  String.prototype.format = function() {
	var args = arguments;
	return this.replace(/{(\d+)}/g, function(match, number) {
	  return typeof args[number] != 'undefined'
		? args[number]
		: match
	  ;
	});
  };
}

function findChild(parent, elemType) {
	for (var i = 0; i < parent.childNodes.length; i++) {
		var child = parent.childNodes[i];
		if (child.nodeType == 1 && child.nodeName == elemType) {
			return child;
		}
	}
}

function clearSvgTooltips(nodeList) {
	for (var i = 0; i < nodeList.length; i++) {
		nodeList.item(i).textContent = '';
	}
}

function createSignalGraphView(Elm, elmDebugger) {
	var Prelude = Elm.Prelude.make({});
	function nodeValueToString(node) {
		if (node === elmDebugger.mainNode) {
			return 'main';
		}
		return Prelude.show(node.value);
	}

	var allInputs = filterReachableNodes(elmDebugger.allNodes, elmDebugger.mainNode);
	var nodesById = {};
	allInputs.forEach(function(x) {
		nodesById[x.id] = x;
	});

	var dotLines = [];
	allInputs.forEach(function(node) {
		var shape = getShapeForNodeType(node.nodeType);

		var initialLabel = nodeValueToString(node).replace(/"/g, '_');
		var labelPadding = new Array(Math.ceil(initialLabel.length/2)).join("_");
		dotLines.push('{0} [id="svgNode{0}", label="{1}", shape="{2}"];'.format(node.id, initialLabel + labelPadding, shape))

		node.kids.forEach(function(child) {
			if (nodesById.hasOwnProperty(child.id)) {
				var edgeStyle = 'solid';
				if (child.nodeType == 'sampleOn' && child.indirectParent === node) {
					edgeStyle = 'dashed';
				}
				dotLines.push('{0} -> {1} [style="{2}"];'.format(node.id, child.id, edgeStyle));
			}
		});
	});

	var nodeTypes = ['input', 'lift', 'foldp', 'sampleOn', 'dropRepeats'];
	subgraphLines = [];
	for (var i=0; i < nodeTypes.length; i++) {
		var type = nodeTypes[i];
		dotLines.push('legend{0} [id="legend{0}", label="{1}", shape="{2}"];'.format(i, type, getShapeForNodeType(type)));
		subgraphLines.push('legend{0};'.format(i));
		if (i > 0 && i % 2 == 1) {
			subgraphLines.push('legend{0} -> legend{1} [style=invis];'.format(i-1, i));
		}
	}
	dotLines.push('subgraph cluster0 { style=filled; color=lightgrey; node [style=filled,color=white]; label = "Legend";');
	dotLines.push(subgraphLines.join('\n'));
	dotLines.push('}');

	var sceneGraphDiv = document.getElementById('signalGraphView');
	var graphVizString = "digraph {" + dotLines.join('\n') + "}";
	sceneGraphDiv.innerHTML = Viz(graphVizString, "svg");
	clearSvgTooltips(sceneGraphDiv.getElementsByTagName('title'));

	function updateValues() {
		allInputs.forEach(function(node) {
			var dotNode = document.getElementById('svgNode' + node.id);
			findChild(dotNode, 'text').textContent = nodeValueToString(node);
			findChild(dotNode, 'title').textContent = node.id.toString();
		});
	}

	// replace initialLabel with real value
	updateValues();

	return {
		updateValues: updateValues
	};
};

function filterReachableNodes(nodes, reachTo) {
  function isReachable(node) {
	if (node === reachTo) {
		return true;
	}
	return node.kids.some(isReachable);
  }
  return nodes.filter(isReachable);
}

function getShapeForNodeType(type) {
	switch (type) {
		case 'input': return 'hexagon';
		case 'lift': return 'invtrapezium';
		case 'foldp': return 'rect';
		case 'sampleOn': return 'house';
		case 'constant': return 'none';
		case 'dropRepeats': return 'doubleoctagon';
		default: return 'ellipse';
	}
}




var elmDebugger = {
	restart: function() {},
	pause: function() {},
	kontinue: function() {},
	getMaxSteps: function() { return 0; },
	stepTo: function(i) {},
	getPaused: function() { return false; },
	getHotSwapState: function() { return null; }
};

var signalGraphView = {
	updateValues: function() {}
}

var timeSlider = document.getElementById("timeSlider");
timeSlider.addEventListener('change', function(e) {
	console.log("Time sliding");
	elmDebugger.stepTo(+timeSlider.value);
	signalGraphView.updateValues();
});
document.getElementById('buttonRestart').addEventListener('click', function(e) {
	console.log("Restart");
	elmDebugger.restart();
	refreshDebuggerUI();
});
document.getElementById('buttonPause').addEventListener('click', function(e) {
	console.log("Pause");
	elmDebugger.pause();
	refreshDebuggerUI();
});
document.getElementById('buttonContinue').addEventListener('click', function(e) {
	console.log("Continue");
	elmDebugger.kontinue();
});


function refreshDebuggerUI() {
	signalGraphView.updateValues();
	timeSlider.max = elmDebugger.getMaxSteps();
	if (elmDebugger.getPaused()) {
		timeSlider.disabled = false;
	}
	else {
		timeSlider.disabled = true;
		timeSlider.value = timeSlider.max;
	}
}

function startDebugging(elmWindow) {
	console.log("Debugger started");
	elmDebugger = elmWindow.Elm.Debugger;
	signalGraphView = createSignalGraphView(elmWindow.Elm, elmDebugger);
}

parent.window.addEventListener("message", function(e) {
	if (e.data == "elmDebuggerInit") {
		startDebugging(e.source);
	}
	else if (e.data == "elmNotify") {
		refreshDebuggerUI();
	}
}, false);

</script>
</body>
</html>